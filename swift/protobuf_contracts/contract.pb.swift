// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protobuf_contracts/contract.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Ffi_Contract_DeserializationError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fieldName: String = String()

  var description_p: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ffi_Contract_BytearrayWrongLengthError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fieldName: String = String()

  var expectedLength: UInt32 = 0

  var actualLength: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ffi_Contract_FFIRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var req: Ffi_Contract_FFIRequest.OneOf_Req? = nil

  var encrypt: Ffi_Contract_DeoxysIIEncryptRequest {
    get {
      if case .encrypt(let v)? = req {return v}
      return Ffi_Contract_DeoxysIIEncryptRequest()
    }
    set {req = .encrypt(newValue)}
  }

  var decrypt: Ffi_Contract_DeoxysIIDecryptRequest {
    get {
      if case .decrypt(let v)? = req {return v}
      return Ffi_Contract_DeoxysIIDecryptRequest()
    }
    set {req = .decrypt(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Req: Equatable {
    case encrypt(Ffi_Contract_DeoxysIIEncryptRequest)
    case decrypt(Ffi_Contract_DeoxysIIDecryptRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Ffi_Contract_FFIRequest.OneOf_Req, rhs: Ffi_Contract_FFIRequest.OneOf_Req) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.encrypt, .encrypt): return {
        guard case .encrypt(let l) = lhs, case .encrypt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.decrypt, .decrypt): return {
        guard case .decrypt(let l) = lhs, case .decrypt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Encrypt
struct Ffi_Contract_DeoxysIIEncryptRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var privateKey: Data = Data()

  var data: Data = Data()

  var nodePublicKey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ffi_Contract_DeoxysIIEncryptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: Ffi_Contract_DeoxysIIEncryptResponse.OneOf_Response? = nil

  var success: Ffi_Contract_DeoxysIIEncryptSuccessResponse {
    get {
      if case .success(let v)? = response {return v}
      return Ffi_Contract_DeoxysIIEncryptSuccessResponse()
    }
    set {response = .success(newValue)}
  }

  var failure: Ffi_Contract_DeoxysIIEncryptFailureResponse {
    get {
      if case .failure(let v)? = response {return v}
      return Ffi_Contract_DeoxysIIEncryptFailureResponse()
    }
    set {response = .failure(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    case success(Ffi_Contract_DeoxysIIEncryptSuccessResponse)
    case failure(Ffi_Contract_DeoxysIIEncryptFailureResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Ffi_Contract_DeoxysIIEncryptResponse.OneOf_Response, rhs: Ffi_Contract_DeoxysIIEncryptResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.success, .success): return {
        guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.failure, .failure): return {
        guard case .failure(let l) = lhs, case .failure(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Ffi_Contract_DeoxysIIEncryptSuccessResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ffi_Contract_DeoxysIIEncryptFailureResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Ffi_Contract_DeoxysIIEncryptFailureResponse.OneOf_Error? = nil

  var encryptionError: String {
    get {
      if case .encryptionError(let v)? = error {return v}
      return String()
    }
    set {error = .encryptionError(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Error: Equatable {
    case encryptionError(String)

  #if !swift(>=4.1)
    static func ==(lhs: Ffi_Contract_DeoxysIIEncryptFailureResponse.OneOf_Error, rhs: Ffi_Contract_DeoxysIIEncryptFailureResponse.OneOf_Error) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.encryptionError, .encryptionError): return {
        guard case .encryptionError(let l) = lhs, case .encryptionError(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

/// Decrypt
struct Ffi_Contract_DeoxysIIDecryptRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var privateKey: Data = Data()

  var encryptedData: Data = Data()

  var nodePublicKey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ffi_Contract_DeoxysIIDecryptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: Ffi_Contract_DeoxysIIDecryptResponse.OneOf_Response? = nil

  var success: Ffi_Contract_DeoxysIIDecryptSuccessResponse {
    get {
      if case .success(let v)? = response {return v}
      return Ffi_Contract_DeoxysIIDecryptSuccessResponse()
    }
    set {response = .success(newValue)}
  }

  var failure: Ffi_Contract_DeoxysIIDecryptFailureResponse {
    get {
      if case .failure(let v)? = response {return v}
      return Ffi_Contract_DeoxysIIDecryptFailureResponse()
    }
    set {response = .failure(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    case success(Ffi_Contract_DeoxysIIDecryptSuccessResponse)
    case failure(Ffi_Contract_DeoxysIIDecryptFailureResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Ffi_Contract_DeoxysIIDecryptResponse.OneOf_Response, rhs: Ffi_Contract_DeoxysIIDecryptResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.success, .success): return {
        guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.failure, .failure): return {
        guard case .failure(let l) = lhs, case .failure(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Ffi_Contract_DeoxysIIDecryptSuccessResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ffi_Contract_DeoxysIIDecryptFailureResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Ffi_Contract_DeoxysIIDecryptFailureResponse.OneOf_Error? = nil

  var decryptionError: String {
    get {
      if case .decryptionError(let v)? = error {return v}
      return String()
    }
    set {error = .decryptionError(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Error: Equatable {
    case decryptionError(String)

  #if !swift(>=4.1)
    static func ==(lhs: Ffi_Contract_DeoxysIIDecryptFailureResponse.OneOf_Error, rhs: Ffi_Contract_DeoxysIIDecryptFailureResponse.OneOf_Error) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.decryptionError, .decryptionError): return {
        guard case .decryptionError(let l) = lhs, case .decryptionError(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Ffi_Contract_DeserializationError: @unchecked Sendable {}
extension Ffi_Contract_BytearrayWrongLengthError: @unchecked Sendable {}
extension Ffi_Contract_FFIRequest: @unchecked Sendable {}
extension Ffi_Contract_FFIRequest.OneOf_Req: @unchecked Sendable {}
extension Ffi_Contract_DeoxysIIEncryptRequest: @unchecked Sendable {}
extension Ffi_Contract_DeoxysIIEncryptResponse: @unchecked Sendable {}
extension Ffi_Contract_DeoxysIIEncryptResponse.OneOf_Response: @unchecked Sendable {}
extension Ffi_Contract_DeoxysIIEncryptSuccessResponse: @unchecked Sendable {}
extension Ffi_Contract_DeoxysIIEncryptFailureResponse: @unchecked Sendable {}
extension Ffi_Contract_DeoxysIIEncryptFailureResponse.OneOf_Error: @unchecked Sendable {}
extension Ffi_Contract_DeoxysIIDecryptRequest: @unchecked Sendable {}
extension Ffi_Contract_DeoxysIIDecryptResponse: @unchecked Sendable {}
extension Ffi_Contract_DeoxysIIDecryptResponse.OneOf_Response: @unchecked Sendable {}
extension Ffi_Contract_DeoxysIIDecryptSuccessResponse: @unchecked Sendable {}
extension Ffi_Contract_DeoxysIIDecryptFailureResponse: @unchecked Sendable {}
extension Ffi_Contract_DeoxysIIDecryptFailureResponse.OneOf_Error: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ffi.contract"

extension Ffi_Contract_DeserializationError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeserializationError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "field_name"),
    2: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fieldName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fieldName.isEmpty {
      try visitor.visitSingularStringField(value: self.fieldName, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ffi_Contract_DeserializationError, rhs: Ffi_Contract_DeserializationError) -> Bool {
    if lhs.fieldName != rhs.fieldName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ffi_Contract_BytearrayWrongLengthError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BytearrayWrongLengthError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "field_name"),
    2: .standard(proto: "expected_length"),
    3: .standard(proto: "actual_length"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fieldName) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.expectedLength) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.actualLength) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fieldName.isEmpty {
      try visitor.visitSingularStringField(value: self.fieldName, fieldNumber: 1)
    }
    if self.expectedLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.expectedLength, fieldNumber: 2)
    }
    if self.actualLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.actualLength, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ffi_Contract_BytearrayWrongLengthError, rhs: Ffi_Contract_BytearrayWrongLengthError) -> Bool {
    if lhs.fieldName != rhs.fieldName {return false}
    if lhs.expectedLength != rhs.expectedLength {return false}
    if lhs.actualLength != rhs.actualLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ffi_Contract_FFIRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FFIRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encrypt"),
    2: .same(proto: "decrypt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Ffi_Contract_DeoxysIIEncryptRequest?
        var hadOneofValue = false
        if let current = self.req {
          hadOneofValue = true
          if case .encrypt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.req = .encrypt(v)
        }
      }()
      case 2: try {
        var v: Ffi_Contract_DeoxysIIDecryptRequest?
        var hadOneofValue = false
        if let current = self.req {
          hadOneofValue = true
          if case .decrypt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.req = .decrypt(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.req {
    case .encrypt?: try {
      guard case .encrypt(let v)? = self.req else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .decrypt?: try {
      guard case .decrypt(let v)? = self.req else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ffi_Contract_FFIRequest, rhs: Ffi_Contract_FFIRequest) -> Bool {
    if lhs.req != rhs.req {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ffi_Contract_DeoxysIIEncryptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeoxysIIEncryptRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "private_key"),
    2: .same(proto: "data"),
    3: .standard(proto: "node_public_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.privateKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nodePublicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.privateKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKey, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.nodePublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodePublicKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ffi_Contract_DeoxysIIEncryptRequest, rhs: Ffi_Contract_DeoxysIIEncryptRequest) -> Bool {
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.data != rhs.data {return false}
    if lhs.nodePublicKey != rhs.nodePublicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ffi_Contract_DeoxysIIEncryptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeoxysIIEncryptResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Ffi_Contract_DeoxysIIEncryptSuccessResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .success(v)
        }
      }()
      case 2: try {
        var v: Ffi_Contract_DeoxysIIEncryptFailureResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .failure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .failure(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .success?: try {
      guard case .success(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .failure?: try {
      guard case .failure(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ffi_Contract_DeoxysIIEncryptResponse, rhs: Ffi_Contract_DeoxysIIEncryptResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ffi_Contract_DeoxysIIEncryptSuccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeoxysIIEncryptSuccessResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.result.isEmpty {
      try visitor.visitSingularBytesField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ffi_Contract_DeoxysIIEncryptSuccessResponse, rhs: Ffi_Contract_DeoxysIIEncryptSuccessResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ffi_Contract_DeoxysIIEncryptFailureResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeoxysIIEncryptFailureResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "encryption_error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.error != nil {try decoder.handleConflictingOneOf()}
          self.error = .encryptionError(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .encryptionError(let v)? = self.error {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ffi_Contract_DeoxysIIEncryptFailureResponse, rhs: Ffi_Contract_DeoxysIIEncryptFailureResponse) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ffi_Contract_DeoxysIIDecryptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeoxysIIDecryptRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "private_key"),
    2: .standard(proto: "encrypted_data"),
    3: .standard(proto: "node_public_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.privateKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.encryptedData) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nodePublicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.privateKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKey, fieldNumber: 1)
    }
    if !self.encryptedData.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedData, fieldNumber: 2)
    }
    if !self.nodePublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodePublicKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ffi_Contract_DeoxysIIDecryptRequest, rhs: Ffi_Contract_DeoxysIIDecryptRequest) -> Bool {
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.encryptedData != rhs.encryptedData {return false}
    if lhs.nodePublicKey != rhs.nodePublicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ffi_Contract_DeoxysIIDecryptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeoxysIIDecryptResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Ffi_Contract_DeoxysIIDecryptSuccessResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .success(v)
        }
      }()
      case 2: try {
        var v: Ffi_Contract_DeoxysIIDecryptFailureResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .failure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .failure(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .success?: try {
      guard case .success(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .failure?: try {
      guard case .failure(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ffi_Contract_DeoxysIIDecryptResponse, rhs: Ffi_Contract_DeoxysIIDecryptResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ffi_Contract_DeoxysIIDecryptSuccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeoxysIIDecryptSuccessResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.result.isEmpty {
      try visitor.visitSingularBytesField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ffi_Contract_DeoxysIIDecryptSuccessResponse, rhs: Ffi_Contract_DeoxysIIDecryptSuccessResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ffi_Contract_DeoxysIIDecryptFailureResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeoxysIIDecryptFailureResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "decryption_error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.error != nil {try decoder.handleConflictingOneOf()}
          self.error = .decryptionError(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .decryptionError(let v)? = self.error {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ffi_Contract_DeoxysIIDecryptFailureResponse, rhs: Ffi_Contract_DeoxysIIDecryptFailureResponse) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
